"""create columns like_count and dislike_count in post model

Revision ID: 763ac236663f
Revises: 3324dbd7cbea
Create Date: 2025-05-05 21:35:40.621605

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '763ac236663f'
down_revision: Union[str, None] = '3324dbd7cbea'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('post', sa.Column('likes_count', sa.Integer(), nullable=False, server_default="0"))
    op.add_column('post', sa.Column('dislikes_count', sa.Integer(), nullable=False, server_default="0"))
    # ### end Alembic commands ###

    # 2) Заполняем существующие записи «правильными» значениями
    op.execute("""
      UPDATE post p
      SET likes_count = COALESCE((
            SELECT COUNT(*) FROM "likes" l
            WHERE l.content_type = 'post' AND l.content_id = p.id
          ), 0),
          dislikes_count = COALESCE((
            SELECT COUNT(*) FROM "dislike" d
            WHERE d.content_type = 'post' AND d.content_id = p.id
          ), 0);
    """)

    # 3) Создаём функцию-триггер для лайков
    op.execute("""
    CREATE FUNCTION trg_update_post_likes() RETURNS trigger AS $$
    BEGIN
        IF TG_OP = 'INSERT' THEN
            UPDATE post SET likes_count = likes_count + 1 WHERE id = NEW.content_id;
        ELSIF TG_OP = 'DELETE' THEN
            UPDATE post SET likes_count = GREATEST(likes_count - 1, 0) WHERE id = OLD.content_id;
        END IF;
        RETURN NULL;
    END;
    $$ LANGUAGE plpgsql;
    """)

    # 4) Отдельно навешиваем триггеры лайков
    op.execute("""
    CREATE TRIGGER on_like_insert
      AFTER INSERT ON likes
      FOR EACH ROW
      WHEN (NEW.content_type = 'post')
      EXECUTE FUNCTION trg_update_post_likes();
    """)
    op.execute("""
    CREATE TRIGGER on_like_delete
      AFTER DELETE ON likes
      FOR EACH ROW
      WHEN (OLD.content_type = 'post')
      EXECUTE FUNCTION trg_update_post_likes();
    """)

    # 5) Создаём функцию-триггер для дизлайков (отдельно!)
    op.execute("""
    CREATE FUNCTION trg_update_post_dislikes() RETURNS trigger AS $$
    BEGIN
        IF TG_OP = 'INSERT' THEN
            UPDATE post SET dislikes_count = dislikes_count + 1 WHERE id = NEW.content_id;
        ELSIF TG_OP = 'DELETE' THEN
            UPDATE post SET dislikes_count = GREATEST(dislikes_count - 1, 0) WHERE id = OLD.content_id;
        END IF;
        RETURN NULL;
    END;
    $$ LANGUAGE plpgsql;
    """)

    # 6) Отдельно навешиваем триггеры дизлайков
    op.execute("""
    CREATE TRIGGER on_dislike_insert
      AFTER INSERT ON dislike
      FOR EACH ROW
      WHEN (NEW.content_type = 'post')
      EXECUTE FUNCTION trg_update_post_dislikes();
    """)
    op.execute("""
    CREATE TRIGGER on_dislike_delete
      AFTER DELETE ON dislike
      FOR EACH ROW
      WHEN (OLD.content_type = 'post')
      EXECUTE FUNCTION trg_update_post_dislikes();
    """)

def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('post', 'dislikes_count')
    op.drop_column('post', 'likes_count')
    # ### end Alembic commands ###
